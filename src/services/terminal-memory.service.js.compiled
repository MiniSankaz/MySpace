"use strict";
/**
 * In-Memory Terminal Service
 * Manages terminal sessions without database persistence
 * Solves sync issues and provides reliable session management
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.inMemoryTerminalService = exports.InMemoryTerminalService = void 0;
const events_1 = require("events");
/**
 * In-Memory Terminal Service
 * Single source of truth for all terminal sessions
 */
class InMemoryTerminalService extends events_1.EventEmitter {
    constructor() {
        super();
        // In-memory storage - no database dependency
        this.sessions = new Map();
        this.projectSessions = new Map();
        this.wsConnections = new Map();
        // Session counters for tab naming
        this.sessionCounters = new Map();
        console.log('[InMemoryTerminalService] Initialized');
        // Cleanup inactive sessions every 10 minutes
        setInterval(() => {
            this.cleanupInactiveSessions();
        }, 10 * 60 * 1000);
    }
    /**
     * Get singleton instance
     */
    static getInstance() {
        if (!InMemoryTerminalService.instance) {
            InMemoryTerminalService.instance = new InMemoryTerminalService();
        }
        return InMemoryTerminalService.instance;
    }
    /**
     * Generate unique session ID
     */
    generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
    }
    /**
     * Get WebSocket URL for terminal type
     */
    getWebSocketUrl(type) {
        const port = type === 'system' ? 4001 : 4002;
        return `ws://localhost:${port}`;
    }
    /**
     * Get next tab name for project and type
     */
    getNextTabName(projectId, type) {
        if (!this.sessionCounters.has(projectId)) {
            this.sessionCounters.set(projectId, { system: 0, claude: 0 });
        }
        const counters = this.sessionCounters.get(projectId);
        counters[type]++;
        return type === 'claude'
            ? `Claude ${counters.claude}`
            : `Terminal ${counters.system}`;
    }
    /**
     * Create new terminal session
     */
    createSession(projectId, type, projectPath, userId) {
        const sessionId = this.generateSessionId();
        const tabName = this.getNextTabName(projectId, type);
        const session = {
            id: sessionId,
            projectId,
            userId,
            type,
            tabName,
            status: 'connecting',
            active: true,
            isFocused: false,
            createdAt: new Date(),
            updatedAt: new Date(),
            currentPath: projectPath || process.cwd(),
            wsConnected: false,
            metadata: {}
        };
        // Store session
        this.sessions.set(sessionId, session);
        // Track project sessions
        if (!this.projectSessions.has(projectId)) {
            this.projectSessions.set(projectId, new Set());
        }
        this.projectSessions.get(projectId).add(sessionId);
        // Initialize WebSocket info
        this.wsConnections.set(sessionId, {
            sessionId,
            connected: false,
            lastPing: new Date()
        });
        console.log(`[InMemoryTerminalService] Created session ${sessionId} for project ${projectId}`);
        this.emit('sessionCreated', session);
        return session;
    }
    /**
     * List sessions for a project
     */
    listSessions(projectId) {
        const sessionIds = this.projectSessions.get(projectId);
        if (!sessionIds) {
            return [];
        }
        const sessions = [];
        for (const sessionId of sessionIds) {
            const session = this.sessions.get(sessionId);
            if (session && session.status !== 'closed') {
                sessions.push(session);
            }
        }
        return sessions.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
    }
    /**
     * Get session by ID
     */
    getSession(sessionId) {
        if (!sessionId) {
            console.warn('[InMemoryTerminalService] getSession called with null/undefined sessionId');
            return null;
        }
        return this.sessions.get(sessionId) || null;
    }
    /**
     * Update session status
     */
    updateSessionStatus(sessionId, status) {
        if (!sessionId) {
            console.warn('[InMemoryTerminalService] updateSessionStatus called with null/undefined sessionId');
            return;
        }
        const session = this.sessions.get(sessionId);
        if (session) {
            session.status = status;
            session.updatedAt = new Date();
            if (status === 'active') {
                session.wsConnected = true;
            }
            else if (status === 'closed' || status === 'error') {
                session.wsConnected = false;
                session.active = false;
            }
        }
        else {
            console.warn(`[InMemoryTerminalService] Session ${sessionId} not found for status update`);
        }
        console.log(`[InMemoryTerminalService] Session ${sessionId} status: ${status}`);
        this.emit('sessionStatusChanged', session);
    }
    /**
     * Register WebSocket connection for existing session
     */
    registerWebSocketConnection(sessionId, ws) {
        if (!sessionId) {
            console.warn('[InMemoryTerminalService] registerWebSocketConnection called with null/undefined sessionId');
            return;
        }
        // Check if session exists
        const session = this.sessions.get(sessionId);
        if (!session) {
            console.warn(`[InMemoryTerminalService] Cannot register WebSocket for non-existent session: ${sessionId}`);
            return;
        }
        // Update WebSocket connection info
        let wsInfo = this.wsConnections.get(sessionId);
        if (!wsInfo) {
            // Create new WebSocket info if doesn't exist
            wsInfo = {
                sessionId,
                ws,
                connected: true,
                lastPing: new Date()
            };
            this.wsConnections.set(sessionId, wsInfo);
        }
        else {
            // Update existing WebSocket info
            wsInfo.ws = ws;
            wsInfo.connected = true;
            wsInfo.lastPing = new Date();
        }
        // Update session status
        session.wsConnected = true;
        session.status = 'active';
        session.updatedAt = new Date();
        console.log(`[InMemoryTerminalService] Registered WebSocket for session ${sessionId}`);
        this.emit('sessionWebSocketConnected', { sessionId });
    }
    /**
     * Update session activity timestamp
     */
    updateSessionActivity(sessionId) {
        if (!sessionId) {
            return;
        }
        const session = this.sessions.get(sessionId);
        if (session) {
            session.updatedAt = new Date();
        }
        const wsInfo = this.wsConnections.get(sessionId);
        if (wsInfo) {
            wsInfo.lastPing = new Date();
        }
    }
    /**
     * Set session focus
     */
    setSessionFocus(sessionId, focused) {
        const session = this.sessions.get(sessionId);
        if (session) {
            // Unfocus other sessions of the same type in the same project
            if (focused) {
                const projectSessionIds = this.projectSessions.get(session.projectId);
                if (projectSessionIds) {
                    for (const sid of projectSessionIds) {
                        const s = this.sessions.get(sid);
                        if (s && s.type === session.type && s.id !== sessionId) {
                            s.isFocused = false;
                        }
                    }
                }
            }
            session.isFocused = focused;
            session.updatedAt = new Date();
            console.log(`[InMemoryTerminalService] Session ${sessionId} focus: ${focused}`);
        }
    }
    /**
     * Close a terminal session
     */
    closeSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            return false;
        }
        // Update session status
        session.status = 'closed';
        session.active = false;
        session.wsConnected = false;
        session.updatedAt = new Date();
        // Remove from project sessions
        const projectSessionIds = this.projectSessions.get(session.projectId);
        if (projectSessionIds) {
            projectSessionIds.delete(sessionId);
            if (projectSessionIds.size === 0) {
                this.projectSessions.delete(session.projectId);
            }
        }
        // Remove WebSocket connection info
        this.wsConnections.delete(sessionId);
        // Remove session from memory after a delay (for cleanup)
        setTimeout(() => {
            this.sessions.delete(sessionId);
        }, 5000);
        console.log(`[InMemoryTerminalService] Closed session ${sessionId}`);
        this.emit('sessionClosed', session);
        return true;
    }
    /**
     * Clean up all sessions for a project
     */
    cleanupProjectSessions(projectId) {
        const sessionIds = this.projectSessions.get(projectId);
        if (!sessionIds) {
            return 0;
        }
        let closedCount = 0;
        for (const sessionId of sessionIds) {
            if (this.closeSession(sessionId)) {
                closedCount++;
            }
        }
        // Reset counters for the project
        this.sessionCounters.delete(projectId);
        console.log(`[InMemoryTerminalService] Cleaned up ${closedCount} sessions for project ${projectId}`);
        return closedCount;
    }
    /**
     * Update WebSocket connection status
     */
    updateWebSocketStatus(sessionId, connected) {
        const wsInfo = this.wsConnections.get(sessionId);
        if (wsInfo) {
            wsInfo.connected = connected;
            wsInfo.lastPing = new Date();
        }
        const session = this.sessions.get(sessionId);
        if (session) {
            session.wsConnected = connected;
            session.status = connected ? 'active' : 'inactive';
            session.updatedAt = new Date();
        }
    }
    /**
     * Clean up inactive sessions
     */
    cleanupInactiveSessions() {
        const now = Date.now();
        const timeout = 30 * 60 * 1000; // 30 minutes
        for (const [sessionId, session] of this.sessions) {
            if (session.status === 'closed') {
                continue;
            }
            const timeSinceUpdate = now - session.updatedAt.getTime();
            if (timeSinceUpdate > timeout && !session.wsConnected) {
                console.log(`[InMemoryTerminalService] Auto-closing inactive session ${sessionId}`);
                this.closeSession(sessionId);
            }
        }
    }
    /**
     * Get all active sessions (for debugging)
     */
    getAllSessions() {
        return Array.from(this.sessions.values()).filter(s => s.status !== 'closed');
    }
    /**
     * Clear all sessions (for testing)
     */
    clearAllSessions() {
        for (const sessionId of this.sessions.keys()) {
            this.closeSession(sessionId);
        }
        this.sessions.clear();
        this.projectSessions.clear();
        this.wsConnections.clear();
        this.sessionCounters.clear();
        console.log('[InMemoryTerminalService] All sessions cleared');
    }
}
exports.InMemoryTerminalService = InMemoryTerminalService;
// Export singleton instance
exports.inMemoryTerminalService = InMemoryTerminalService.getInstance();
